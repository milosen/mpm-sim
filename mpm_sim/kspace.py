from typing import Tuple, List
import logging

import h5py
import numpy as np

from mpm_sim.utils import plot_matrix
from bart.cfl import writecfl


def load_h5_signal(signal_file: str) -> Tuple[np.ndarray, np.ndarray]:
    """Read JEMRIS signal file (simulation output) and return tuple of arrays,
    one for magnetization and one for the time points.

    :param signal_file: JEMRIS output
    :return: Tuple: 1) sorted time points, 2) magnetization time series of shape
    (no_timepoints, 3) with separated vector components)
    """
    with h5py.File(signal_file, 'r') as f:
        channels = f['signal']['channels']
        times = np.array(f['signal']['times'])

        sorting_time_indices = times.argsort(axis=0)
        magnetization_sorted_by_time = np.array(
            [channels[i][sorting_time_indices] for i in channels]
        )

    return times[sorting_time_indices], magnetization_sorted_by_time


def complexify_signals(signals: np.ndarray) -> np.ndarray:
    """Use first and second magnetization vector component for building complex
    signal (Mx + iMy).

    :param signals:
    :return:
    """
    return np.array([
        # calculate Mx + iMy for each time point
        # return array of shape (channels, no_time_points)
        [complex(a, b) for a, b in zip(channel[:, 1], channel[:, 0])] for channel in signals
    ])


def order_kspace(signals: np.ndarray, dimensions: tuple) -> np.ndarray:
    """Sort MRI signal into kspace

    :param signals: array of mri signal data
    :param dimensions:
    :return: ndarray of shape (..., channels) representing the kspace data, where ... must be specified by dimensions
    """
    channels = signals.shape[0]
    logging.debug(f"Signal shape: {signals.shape}")
    mxy = complexify_signals(signals)
    logging.debug(f"Shape of transverse relaxation (Mx+iMy): {mxy.shape}")
    try:
        mxy = np.reshape(mxy.transpose(), dimensions + (channels, ), order='F')
    except ValueError:
        raise ValueError('Please make sure that your signal can be reshaped into the '
                         'specified dimensions using this number of echos.')
    return mxy


def flash_order_kspace(signals: np.ndarray, dimensions: Tuple[int, int, int],
                       echos: int) -> np.ndarray:
    """Sort MRI signal into kspace, assuming the signal was generated by a
    FLASH sequence with full kspace sampling. Each channel will be treated separately.

    :param signals:
    :param dimensions:
    :param echos:
    :return: ndarray of shape (z, echos, y, x, channels) representing the kspace data
    """
    x, y, z = dimensions
    return order_kspace(signals=signals, dimensions=(z, echos, y, x))


def write_kspace(signals_h5, dims, echoes, plot=True):
    _, signal = load_h5_signal(signals_h5)
    kspace = flash_order_kspace(signal, dimensions=dims, echos=echoes)
    for echo in range(echoes):
        if echo % 2 == 1:
            kspace[:, echo, :, :, :] = np.flip(kspace[:, echo, :, :, :], axis=0)

    kspace_file_path = signals_h5.absolute().parent / "kspace"
    logging.info("Writing kspace to: ", kspace_file_path)
    logging.info("Shape of kspace data: ", kspace.shape)
    writecfl(kspace_file_path, kspace)

    if plot:
        idx_plot_channel = 0
        idx_plot_echo = 0
        idx_plot_slice = round(dims[0] / 2) - 1  # plot a central slice
        logging.info(f"Plotting echo {idx_plot_echo + 1}, channel {idx_plot_channel + 1}, slice {idx_plot_slice + 1}")
        plot_kspace = kspace[:, idx_plot_echo, :, idx_plot_slice, idx_plot_channel]
        plot_matrix(np.absolute(plot_kspace))
        img = np.absolute(np.fft.ifftshift(np.fft.ifft2(plot_kspace)))
        plot_matrix(img)
